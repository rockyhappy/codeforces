
long long int modulo(long long int x, long long int m) {
    return (x % m + m) % m;
}


long long int kadane(vector<long long int> vec)
{
    long long int max_sum=LONG_LONG_MIN;
    long long int sum=0;
    for (int i = 0; i < vec.size(); i++)
    {
        sum+=vec[i];
        max_sum=max(max_sum,sum);
        if(sum<0)
        {
            sum=0;
        }
    }
    return max_sum;
}


map<int, int> primeFactors(int n)
{
    map<int, int> ans;
    while (n % 2 == 0)
    {
        ans[2]++;
        n = n / 2;
    }
    for (int i = 3; i <= sqrt(n); i = i + 2)
    {
        while (n % i == 0)
        {
            ans[i]++;
            n = n / i;
        }
    }
    if (n > 2)
    {
        ans[n]++;
    }
    return ans;
}


long long int countBinaryInversions(vector<int> vec)
{
    int n=vec.size();
    int cntZero=0,cntOne=0;
    long long int ans=0;
    for (int  i = 0; i < n; i++)
    {
        if(vec[i]==0)
        {
            ans+=cntOne;
            cntZero++;
        }
        else
        {
            cntOne++;
        }
    }
    return ans;
}


int MEX(vector<int> vec)
{
    int n = vec.size();
    set<int> s;
    for (int i = 0; i < n; i++)
    {
        s.insert(vec[i]);
    }
    for (int i = 0; i <= n; i++)
    {
        if (s.find(i) == s.end())
        {
            return i;
        }
    }
    return n + 1;
}


vector<int> SeiveOfEratosthenes(int n)
{
    vector<int> prime(n + 1, 1);
    prime[0] = 0;
    prime[1] = 0;
    for (int p = 2; p * p <= n; p++)
    {
        if (prime[p] == 1)
        {
            for (int i = p * p; i <= n; i += p)
                prime[i] = 0;
        }
    }
    return prime;
}


int longestStreak(vector<int> vec, int x)
{
    int maxStreak = 0;
    int currentStreak = 0;
    for (int i = 0; i < vec.size(); i++)
    {
        if (vec[i] == x)
        {
            currentStreak++;
            maxStreak = max(maxStreak, currentStreak);
        }
        else
        {
            currentStreak = 0;
        }
    }
    return maxStreak;
}